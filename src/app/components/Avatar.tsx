/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model/Avatar.glb -o src/app/components/Avatar.tsx -r public 
*/

import * as THREE from 'three'
import React, { JSX, useEffect, useRef, useState } from 'react'
import { useGraph } from '@react-three/fiber'
import { useAnimations, useFBX, useGLTF } from '@react-three/drei'
import { GLTF, SkeletonUtils } from 'three-stdlib'
import { gsap } from 'gsap'

type GLTFResult = GLTF & {
  nodes: {
    Wolf3D_Hair: THREE.SkinnedMesh
    Wolf3D_Outfit_Top: THREE.SkinnedMesh
    Wolf3D_Outfit_Bottom: THREE.SkinnedMesh
    Wolf3D_Outfit_Footwear: THREE.SkinnedMesh
    Wolf3D_Body: THREE.SkinnedMesh
    EyeLeft: THREE.SkinnedMesh
    EyeRight: THREE.SkinnedMesh
    Wolf3D_Head: THREE.SkinnedMesh
    Wolf3D_Teeth: THREE.SkinnedMesh
    Hips: THREE.Bone
  }
  materials: {
    Wolf3D_Hair: THREE.MeshStandardMaterial
    Wolf3D_Outfit_Top: THREE.MeshStandardMaterial
    Wolf3D_Outfit_Bottom: THREE.MeshStandardMaterial
    Wolf3D_Outfit_Footwear: THREE.MeshStandardMaterial
    Wolf3D_Body: THREE.MeshStandardMaterial
    Wolf3D_Eye: THREE.MeshStandardMaterial
    Wolf3D_Skin: THREE.MeshStandardMaterial
    Wolf3D_Teeth: THREE.MeshStandardMaterial
  }
}

const AvatarComponent = (props: JSX.IntrinsicElements['group']) => {
  const { scene } = useGLTF('/model/Avatar.glb')
  const {animations: saluteAnimation} = useFBX("/animations/Salute.fbx")
  const {animations: dancingAnimation} = useFBX("/animations/Silly Dancing.fbx")
  const {animations: breathingAnimation} = useFBX("/animations/Breathing Idle.fbx")
  const {animations: sadAnimation} = useFBX("/animations/Sad Idle.fbx")
  const {animations: fallingAnimation} = useFBX("/animations/Falling Idle.fbx")
  const {animations: landingAnimation} = useFBX("/animations/Falling To Landing.fbx")

  if (saluteAnimation[0]) saluteAnimation[0].name = "Salute"
  if (dancingAnimation[0]) dancingAnimation[0].name = "Silly Dancing"
  if (breathingAnimation[0]) breathingAnimation[0].name = "Breathing Idle"
  if (sadAnimation[0]) sadAnimation[0].name = "Sad Idle"
  if (fallingAnimation[0]) fallingAnimation[0].name = "Falling Idle"
  if (landingAnimation[0]) landingAnimation[0].name = "Falling To Landing"

  const animationsList = [
    saluteAnimation[0]?.name,
    dancingAnimation[0]?.name,
    sadAnimation[0]?.name
  ].filter(Boolean) as string[];

  const group = useRef<THREE.Group>(null);
  const { actions } = useAnimations(
    [
      saluteAnimation[0],
      dancingAnimation[0],
      breathingAnimation[0],
      sadAnimation[0],
      fallingAnimation[0],
      landingAnimation[0],
    ].filter(Boolean),
    group
  );

  const currentAnimation = useRef('Breathing Idle');
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => {
    const timeout = setTimeout(() => setIsMounted(true), 200);
    return () => clearTimeout(timeout);
  }, []);

  useEffect(() => {
    if (!isMounted || !group.current) return;

    gsap.set(group.current.scale, { x: 0, y: 0, z: 0 });
    gsap.set(group.current.position, { y: -1 });

    gsap.to(group.current.scale, {
      x: 3.2,
      y: 3.2,
      z: 3.2,
      duration: 1,
      ease: 'power3.out',
      delay: 1,
    });
    gsap.to(group.current.position, {
      y: -4,
      z: -1,
      x: -2,
      duration: 1,
      ease: 'power3.out',
      delay: 1,
    });

    if (!actions || Object.keys(actions).length === 0) return;

    actions['Breathing Idle']?.play();

    let timeout: NodeJS.Timeout;

    const switchAnimation = () => {
      const oldAnimationName = currentAnimation.current;
      const newAnimationName =
        oldAnimationName === 'Breathing Idle'
          ? animationsList[Math.floor(Math.random() * animationsList.length)]
          : 'Breathing Idle';

      const oldAction = actions[oldAnimationName];
      const newAction = actions[newAnimationName];

      if (oldAction && newAction) {
        newAction.reset().play();
        oldAction.crossFadeTo(newAction, 0.5, true);
        currentAnimation.current = newAnimationName;
      }

      timeout = setTimeout(switchAnimation, 10000);
    };

    timeout = setTimeout(switchAnimation, 10000);

    let hasFallen = false;
    let landingTimeout: NodeJS.Timeout;
    let idleTimeout: NodeJS.Timeout;

    const handleScroll = () => {
      const aboutSection = document.getElementById('about');
      if (aboutSection && !hasFallen) {
        const { top } = aboutSection.getBoundingClientRect();
        if (top <= window.innerHeight * 0.7) {
          hasFallen = true;

          const oldAction = actions[currentAnimation.current];
          const newAction = actions['Falling Idle'];

          if (oldAction && newAction) {
            newAction.reset().play();
            oldAction.crossFadeTo(newAction, 0.5, true);
            currentAnimation.current = 'Falling Idle';
          }

          landingTimeout = setTimeout(() => {
            const oldAction = actions['Falling Idle'];
            const newAction = actions['Falling To Landing'];
            if (oldAction && newAction) {
              newAction.reset().play().setLoop(THREE.LoopOnce, 1);
              newAction.clampWhenFinished = true;
              oldAction.crossFadeTo(newAction, 0.5, true);
              currentAnimation.current = 'Falling To Landing';

              idleTimeout = setTimeout(() => {
                const landingAction = actions['Falling To Landing'];
                const idleAction = actions['Breathing Idle'];
                if (landingAction && idleAction) {
                  idleAction.reset().play();
                  landingAction.crossFadeTo(idleAction, 0.5, true);
                  currentAnimation.current = 'Breathing Idle';
                }
              }, 2000); // Adjust this timeout based on the length of the landing animation
            }
          }, 1000); // Delay to sync with canvas movement
        }
      }
    };

    window.addEventListener('scroll', handleScroll);

    return () => {
      clearTimeout(timeout);
      clearTimeout(landingTimeout);
      clearTimeout(idleTimeout);
      window.removeEventListener('scroll', handleScroll);
      Object.values(actions).forEach((action) => action?.fadeOut(0.5));
    };
  }, [isMounted, actions, animationsList]);

  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone as THREE.Object3D) as unknown as GLTFResult
  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} castShadow={false} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} castShadow={false} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} castShadow={false} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} castShadow={false} />
      <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} castShadow={false} />
      <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} castShadow={false} />
      <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} castShadow={false} />
      <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} castShadow={false} />
      <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} castShadow={false} />
    </group>
  )
}

export const Avatar = React.memo(AvatarComponent);
useGLTF.preload('/model/Avatar.glb')
